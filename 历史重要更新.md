#### 历史重要更新

### 序列化优化 2020/08/08
之前建立的抽象有点问题，最近又研究了一遍protoBuf和bson，修正了某些抽象。类数量减少，概念减少，支持却更强大了。  
另外，增强了对netty的ByteBuf的支持，可以利用其自动扩容特性了，分配合适的初始化容量的情况下，多数消息可以直接写入ByteBuf而不必扩容。
注意: 需要重新安装注解处理器。

### Rpc方法代理修正 2020/08/02
最近在基于当前rpc上实现路由转发节点的时候，发现并不方便，思考之后发现请求派发写的有点问题，RpcMethodProxy应该仅仅是执行调用，结果应该由其调用者处理。  
注意: 需要重新安装注解处理器。

### 并发组件优化 2020/05/31 JCTools的Mpsc队列代替ConcurrentLinkedQueue
Disruptor的**RingBuffer**和Jdk的**ConcurrentLinkedQueue**都是多消费者模型，而**EventLoop是多生产者单消费者模型**，使用Mpsc队列可以极大的提高性能。  
Mpsc队列最早是在Netty中看见的，但是苦于是internal的，后来才发现其实是JCTools的，于是引入，作为无界EventLoop的模板，性能确实极好。  

### 并发组件优化 2020/04/30 仿CompletableFuture的FluentFuture 异步操作管道
最近深受异步回调之坑(A->B->C)，寻求解决之道，最终在**CompletableFuture**找到解决方案，**thenCompose**方法可以构建异步操作管道，
可以极大的提高代码的表达力，也更容易维护，用着真的上瘾。不过我并没有直接使用CompletableFuture，而是根据自己的需求仿写了一个**FluentFuture**，
因为部分需求不太一样，而且CompletableFuture有些处理也很坑。  
PS: 最开始的ListenableFuture其实是参考了Netty的Future，其实也参考了Guava的部分，不过Guava当时研究的不深，错失了它的FluentFuture类。
这里我建议大家研究研究JDK的**CompletableFuture**，如果你存在大量异步编程，墙裂建议研究一下。

### 并发组件优化 2020/3/25
删除SingleThreadEventLoop，添加**TemplateEventLoop**，并配套了和DisruptorEventLoop相同的等待策略。 
TemplateEventLoop和DisruptorEventLoop可覆盖方法使用相同的签名，这是故意的，为的就是应用可以方便在两者实现之间进行切换。  
ps: SingleThreadEventLoop实在不是个好名字，EventLoop本就是单线程的，再添加single，感觉EventLoop会是多线程的一样。

### 并发组件和Rpc组件优化 2020/3/8
并发组件重新优化，**ListenableFuture**不再直接继承JDK的future，使得各种轻量级的future实现变成可能。  
基于新的ListenableFuture重新实现了Rpc和Redis的部分组件，删除了旧的**MethodHandle**组件。  
新实现的Rpc组件，更容易理解，更易扩展，更贴近应用本身。  
PS: 需要重新安装注解处理器。

### 序列化支持全新升级 2020年2月18日
新增特性:
1. 支持继承 - 序列化时，会将超类中带有注解的字段一同序列化，即使超类类信息上没有注解。
2. 支持多态解析 - 举个例子：  
 **child1**以**parent**的方式序列化，解析时创建**child2**的实例，并将**parent**的数据赋予**child2**,
 其实底层对于map和collection的处理是一样的，只不过是通过注解来获取合适的实现类。  
 用户需要实现serializer接口，写少量代码即可，更过请查看**EntitySerializer**接口。
3. 支持db注解序列化生成。
4. 所有带注解的类，都生成对应的serializer，能调用普通方法的绝不反射调用，进一步提升编解码效率，现在和protoBuffer的序列化性能几乎相近。
可以运行**SerializePerformanceTest** 和 **ProtoBufSerializePerformanceTest**体验一下，JSON和自定义协议和ProtoBuf自身的性能差异，虽然测试不太规范，但还是能说明问题的。
[生成代码示例图](https://github.com/hl845740757/fastjgame/blob/master/game-net/src/doc/generatedcode.png)  
PS: 需要重新安装注解处理器。

### 2020年2月12日 项目结构调整
从创建仓库到现在已过去9个月，写了不少东西，但是到最近才渐渐明白，之前写的东西，不能叫架构，只能算一套能运行的程序，
其中犯了一个大错误，**架构应只与业务相关，应该与框架无关**，而我的实现处处与框架强依赖。  

如果我自己评价之前的我的话，可以表述为：**有点项目经验，能力还不错，但是根本不懂架构设计**。  
为什么这么说呢？  
对于我经历过的项目，底层都看的很明白，用到的很多技术都懂一些；  
JAVA语言基础、设计模式、重构这些基本功都很扎实，并发、网络编程也还不错；  
深入理解过的框架有netty和disruptor，会用的框架和工具包括mongodb、redis、kafka、OkHttp等；  
游戏内的一些技术，如：怪物AI，技能，寻路，视野管理等也会;  
在我以前的认知里，把这些拼起来，能运行起来，就是所谓的架构，这是**大错特错**。  

举些栗子：
1. 我用过redis，知道jedis，基于jedis封装一套异步api，为什么要用redis？非用redis不可吗？
2. 我用过kafka，基于kafka写了一套将日志发布到kafka，和从kafka拉取日志消费的实现，非用kafka不可吗？
3. 我用过OkHttp，基于OkHttp写了一套Http请求api，非用OkHttp不可吗？
4. 我用过MongoDB，基于MongoDB写了一套数据增删改查的api，但是非用MongoDB不可吗？

对于以上问题，答案当然为**否定的**，因为我有这个锤子，我就得把这个锤子用起来吗？当然不能。之前写的东西总结来说就是：
**都是针对锤子(框架/工具)写的，而不是针对业务写的**，导致**不但业务不明确，且强依赖于框架**，此外还存在一些别的问题，
都表示了我并不懂架构设计，虽然我在写业务逻辑的时候代码组织还不错，但在宏观/高层架构能力不足。现在想一想，我之前项目的某些设计要好过我项目的设计。

**强依赖于框架会存在什么问题？**
1. 框架(工具)会限制你的业务。  
   假设之前的业务你都是依赖redis实现的，现在有个需求，但redis不支持，你就会给策划说，**做不了**！
这样的设计会导致你基于工具去考虑业务，而不是基于业务去选择工具。
2. 更换框架(工具)成本过高，甚至无法更换。  
   假设之前的http请求你都是使用Apache HttpClient实现的，现在某些原因导致希望能同时支持同步请求和异步请求以提升性能，
但是由于大量的地方直接使用了Apache HttpClient相关类，导致切换成本太高，很难保证安全的切换。
3. 其它。

通过不断的学习以及该项目的经验，最近我才从这个思维中跳出来。架构设计这块，知识和技术都非常多，我给自己现在架构能力评价的话：顶多算入门。
**game-log-api**是我入门后第一个产物，它和以前有什么区别？
1. game-log-api是针对日志搜集与日志消费**业务的一套抽象**，它能完整表述**业务整个流程**，看完这套api我们就知道大概做了什么。
2. 不依赖具体的框架(工具)。
3. 不涉及外部细节，如：存在哪，如何存，如何取。
4. 细节的处理是作为**插件**的形式实现的，**game-log-kafka**是一个基于kafka实现的插件，如果想存储在MySql中，那只需要针对MySql写一个插件，
对业务逻辑不造成任何影响。

我其实一直不想自己的项目像你在github或其它地方看见的说自己多么多么流弊，用了哪些哪些技术，但实际代码烂的一塌糊涂的所谓服务器框架一样，
但是我的项目最终也是在慢慢腐烂，也变得类似。  
我还是看过不少项目的，多数人基本功都很差，细节代码的设计乱七八糟，写多线程框架的，多数并发基础都不扎实，稍微看几个类就能发现并发错误，对于架构上的设计，我以前能力也不足，因此没有太多印象。
我自己项目腐烂的主要原因是架构能力的不足。

最后，那么本次更新主要做了些什么呢？
1. 项目重组，本项目只保留底层架构部分，MMO相关模块新建仓库(fastjgame-mmo)，暂时为private，还未开放。  
2. 把用到了什么什么技术啊，这些具体的细节信息从项目介绍中删除了，那不属于架构。**架构应该描述业务逻辑，而不是用了哪些框架**。

#### 重构日志搜集组件，插件式架构 2020年2月11日
**game-log-api模块的core包**定义了日志发布和消费的抽象流程，它与任何日志框架/组件都无关，使得我们可以去除对具体日志组件的依赖。  
定义一套**插件式架构**，使得业务逻辑可以专注于自己的业务，而不必考虑大量细节，细节通过插件的方式实现。  
原理图可见game-log-api模块doc文件下的**日志搜集组件的插件式架构原理图**。
(数据库也是细节，要实现业务逻辑不依赖数据存储方式的话，必须对数据存取建立很好的抽象，这个难度很高，还未准备好)

#### 更友好的异步API支持(MethodHandle + Client) 2020年2月8日
经过几版迭代，提供了更好的异步API支持-见 **MethodHandle**。  
修改了旧版必须先设置回调再进行调用的反人类设计（之前其实也像现在这样实现过，不过想减少对象创建，又改回去了）。  
现在的异步架构设计为**MethodHandle** + **Client**方式，算是较大的改进。  
注意：需要重新安装注解处理器！

#### EventBus优化 添加泛型事件支持 2020年1月19日
去除之前 context + event的实现，新增**GenericEvent**实现，其实是将上下文对象和事件合并为一个对象。  
示例见**SubscriberExample**，本版本需要重新安装注解处理器，否则无效。

#### 为javaBean和自定义枚举生成对应的编解码辅助类 2020年1月14日13:11:45
详情请查看**SerializableClass**类文档，大多数情况下课代替反射，极大提升编解码性能(30%左右)。  
对于普通的JavaBean，会为其生成编解码工具类，而如果有特殊限制的类(eg: 不可变对象)，则会使用反射进行编解码，并不强制必须实现为JavaBean。 
对于自定义枚举，也会为其生成编解码工具类。  
注意：需要重新安装注解处理器！

#### 基于Instrumentation的热更新机制(初版) 2020年1月12日
相对于其它热更新机制(自定义ClassLoader，继承等)，基于Instrumentation的热更新是最方便的。开发方便，执行热更也方便。
修复一般性的bug完全足够。

#### Rpc转发支持 2020年1月4日
RpcCall可以作为普通参数进行传递，可以通关代理工具类获得RpcCall对象，对象保留了要调用的方法信息，然后交给中间层执行真正的调用。  
完善注解处理器的泛型处理信息，需要重新生成注解处理器，否则编译报错。
参考实现：**ICenterRouterMgr**

#### EventBus优化 2019年12月18日(已删除)
EventBus支持抛事件时同时抛出事件对应的上下文信息。  
EventHandler变为双参数接口，可以获得抛出事件时关联的上下文信息。

#### redis支持 2019年12月12日
封装jedis原生的pipeline，提供更好的异步api，支持回调。  
个人感觉一个RedisEventLoop足以应付游戏内的读写需求了。

#### EventBus事件监听优化 2019年12月7日
Subscribe除了订阅函数参数对应的子类型以外，还可以通过types属性指定更多的子类型，仍然由注解处理器注册订阅的类型。
示例见**SubscriberExample**，本版本需要重新安装注解处理器，否则无效。

#### 基于Kafka的日志组件 2019年11月28日
简单的写了一下游戏埋点日志，有些设计来源于之前做的项目，但又有很大的不同，需要安装kafka。  
> 游戏逻辑线程将日志提交给日志线程，日志线程将数据发送到kafka服务器。  
> 消费日志的话，讲道理是单独的进程，而不是游戏服务器。

#### JAVA-ZSET 2019年11月7日
这两天切换了脑袋的上下文，研究了一下redis的zset实现，实现了一个java版的，可用于游戏内的排行榜和拍卖行。  
Q: 为什么需要？  
> 1. 游戏内的排行榜需要信息很多时候不能简单的表示为一个数字。  
> 2. 对逆序排行榜不友好。  
> 3. 数据存储在redis中，不能真实时，交互也不是很方便。  
> 4. 目前手里没有什么比较好的做排行榜的组件。  

#### 网关服节点发现 2019年11月3日
添加网关服组件，实现节点发现相关。最近代码写太多了，写两天翻译去。

#### 场景服架构调整 2019年10月31日
删除纯粹的单服场景服，即每个场景服即提供单服玩法，也提供跨服玩法。该架构有以下优势：  
1. 可以实现更好的负载均衡和高可用。  
2. 可以支持更多的跨服互动。  
PS: 有点伪世界服架构的感觉。

#### 使用EventBus重写了NetEventLoop和NetEventLoop中的接口2019年10月27日
使用EventBus有好有坏，我也是纠结了很久才决定改造的。  
EventBus对于解耦和接口演进很有用，对于性能肯定是会拖慢一点的，另外也会造成可读性的下降。  
Q: 有时候做选择的时候会纠结，为什么纠结呢？  
A: 当不太清楚即将的改动对性能到底有多大影响时就会纠结。。。

#### 重新实现了消息确认机制，支持限流 2019/10/18
重新实现了消息确认机制，不过需要翻译**OuterConnectorHandler**为客户端对应的语言。  
新版本特性：
1. 使用了累积确认机制，可以更快的对数据包进行确认。  
2. 使用了漏桶算法，可以有效的控制发包速率，消息重发也更加安全(有效控制了重发包时的数量)。  

Q: 为什么需要消息确认机制？  
A: 消息确认机制主要针对手机用户的。移动端网络不稳定，很容易产生丢包，socket断开的情况，如果socket断开就使得玩家必须重新登录(包括快速登录)
这个体验是非常差的。消息确认机制可以使得玩家感觉只是产生了延迟。

#### 单向消息/Rpc支持转发，中间节点消除序列化反序列化操作 2019年10月11日
请注意查看**LazySerializable**和PreDeserializable**注解。  
Q: 它主要解决什么问题？  
A: 逻辑服务器通过网关向玩家发送数据，玩家向逻辑服务器发送数据时，在网关服消除冗余的编解码操作。

#### 恢复NetEventLoop多线程模型 2019年10月05日 - 真香
通过sessionId实现粘性session，使得同一个sessionId的数据总是由同一个NetEventLoop来处理，从而保证数据安全性，即使更换channel，仍然支持消息确认机制。

#### 通过SessionPipeline提供功能插拔特性 2019年10月02日
1. 之前的SessionManager代码组织较为混乱，扩展功能较为困难，一直在想办法解决这个问题，这版本引入了类似Netty的ChannelPipeline的SessionPipeline。
通过handler的方式实现插拔功能，以消除重复代码和提升扩展性。  
如：是否使用消息确认机制通过增删handler来实现，内网通信可以不开启，这样内网通信传输的数据量就会减少许多，走到的代码也会少很多。   
又如：服务器与玩家之间是没有rpc的，因此与玩家的session之间也不会有rpc相关的逻辑。  
当然，这是有代价的，代价就是JVM内部传输数据速度变慢，因为有大量的空方法需要执行和冗余判断 - 这些在JVM内部通信之间占的比重还挺大。  
2. **该版本需要重新生成注解处理器**（文件重新归档导致）。
3. 还有很多尚未完成的地方，只是都可以重新运行起来了，还需要继续迭代。

#### 正确的实现DisruptorEventLoop 2019年9月17日
之前实现的Disruptor跑偏了，这两日突然想明白了，进行了正确的实现，相对于**SingleThreadEventLoop**，内存利用率更高，性能也更好，对于追求极致性能的EventLoop提供了很好的框架。  
顺便基于DisruptorEventLoop重写了GameEventLoop。  
如果你想要学习**Disruptor**，那么推荐你看我详细注释过的源码[disruptor-translation](https://github.com/hl845740757/disruptor-translation)  
如果你想学习**Netty**的线程模型，你可以看看我注释过的源码[netty-translation](https://github.com/hl845740757/netty-translation)，netty并没有全部注释，不过并发包是基本是完整注释的。  

#### 修改sync语义 2019年9月13日
同步rpc调用不再插队，而是刷新缓冲区，和其它消息之间也满足先发的先到，后发的后到。

#### LocalSession 2019年9月10日
为JVM内部线程提供session支持，JVM内通信和跨进程之间的通信有相同的API。你可以通过**NetContext**轻松的连接到另一个线程，其通信开销远远小于socket。  
**LocalSessionExample**是一个测试用例。

#### 线程模型调整 2019年9月06日
一个GameEventLoop只承载单个World，具有更简单的编程模型，且更加安全。

#### 注解处理器优化 2019-08-26
注解处理器不再依赖utils和net模块，而是utils依赖auto模块，这样utils和net模块也可以使用自己定义的注解了。

#### EventBus 2019-08-24
1. 在utils包下有一套基础的EventBus实现。
2. 订阅方法代码自动生成。
3. 在example目录下同样提供了一个测试用例，编译后可运行。